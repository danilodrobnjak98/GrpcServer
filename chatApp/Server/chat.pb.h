// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chat.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chat_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chat_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chat_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chat_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chat_2eproto;
namespace ChatApp {
class ChooseParticipantReq;
struct ChooseParticipantReqDefaultTypeInternal;
extern ChooseParticipantReqDefaultTypeInternal _ChooseParticipantReq_default_instance_;
class ChooseParticipantResp;
struct ChooseParticipantRespDefaultTypeInternal;
extern ChooseParticipantRespDefaultTypeInternal _ChooseParticipantResp_default_instance_;
class RegisterReq;
struct RegisterReqDefaultTypeInternal;
extern RegisterReqDefaultTypeInternal _RegisterReq_default_instance_;
class RegisterResp;
struct RegisterRespDefaultTypeInternal;
extern RegisterRespDefaultTypeInternal _RegisterResp_default_instance_;
class SendMessageReq;
struct SendMessageReqDefaultTypeInternal;
extern SendMessageReqDefaultTypeInternal _SendMessageReq_default_instance_;
class SendMessageResp;
struct SendMessageRespDefaultTypeInternal;
extern SendMessageRespDefaultTypeInternal _SendMessageResp_default_instance_;
}  // namespace ChatApp
PROTOBUF_NAMESPACE_OPEN
template<> ::ChatApp::ChooseParticipantReq* Arena::CreateMaybeMessage<::ChatApp::ChooseParticipantReq>(Arena*);
template<> ::ChatApp::ChooseParticipantResp* Arena::CreateMaybeMessage<::ChatApp::ChooseParticipantResp>(Arena*);
template<> ::ChatApp::RegisterReq* Arena::CreateMaybeMessage<::ChatApp::RegisterReq>(Arena*);
template<> ::ChatApp::RegisterResp* Arena::CreateMaybeMessage<::ChatApp::RegisterResp>(Arena*);
template<> ::ChatApp::SendMessageReq* Arena::CreateMaybeMessage<::ChatApp::SendMessageReq>(Arena*);
template<> ::ChatApp::SendMessageResp* Arena::CreateMaybeMessage<::ChatApp::SendMessageResp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ChatApp {

// ===================================================================

class RegisterReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChatApp.RegisterReq) */ {
 public:
  inline RegisterReq() : RegisterReq(nullptr) {}
  ~RegisterReq() override;
  explicit PROTOBUF_CONSTEXPR RegisterReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterReq(const RegisterReq& from);
  RegisterReq(RegisterReq&& from) noexcept
    : RegisterReq() {
    *this = ::std::move(from);
  }

  inline RegisterReq& operator=(const RegisterReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterReq& operator=(RegisterReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterReq* internal_default_instance() {
    return reinterpret_cast<const RegisterReq*>(
               &_RegisterReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RegisterReq& a, RegisterReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterReq& from) {
    RegisterReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChatApp.RegisterReq";
  }
  protected:
  explicit RegisterReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ChatApp.RegisterReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class RegisterResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChatApp.RegisterResp) */ {
 public:
  inline RegisterResp() : RegisterResp(nullptr) {}
  ~RegisterResp() override;
  explicit PROTOBUF_CONSTEXPR RegisterResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterResp(const RegisterResp& from);
  RegisterResp(RegisterResp&& from) noexcept
    : RegisterResp() {
    *this = ::std::move(from);
  }

  inline RegisterResp& operator=(const RegisterResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResp& operator=(RegisterResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResp* internal_default_instance() {
    return reinterpret_cast<const RegisterResp*>(
               &_RegisterResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegisterResp& a, RegisterResp& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterResp& from) {
    RegisterResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChatApp.RegisterResp";
  }
  protected:
  explicit RegisterResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageConfirmationFieldNumber = 1,
  };
  // string messageConfirmation = 1;
  void clear_messageconfirmation();
  const std::string& messageconfirmation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_messageconfirmation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_messageconfirmation();
  PROTOBUF_NODISCARD std::string* release_messageconfirmation();
  void set_allocated_messageconfirmation(std::string* messageconfirmation);
  private:
  const std::string& _internal_messageconfirmation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_messageconfirmation(const std::string& value);
  std::string* _internal_mutable_messageconfirmation();
  public:

  // @@protoc_insertion_point(class_scope:ChatApp.RegisterResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr messageconfirmation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class ChooseParticipantReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChatApp.ChooseParticipantReq) */ {
 public:
  inline ChooseParticipantReq() : ChooseParticipantReq(nullptr) {}
  ~ChooseParticipantReq() override;
  explicit PROTOBUF_CONSTEXPR ChooseParticipantReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChooseParticipantReq(const ChooseParticipantReq& from);
  ChooseParticipantReq(ChooseParticipantReq&& from) noexcept
    : ChooseParticipantReq() {
    *this = ::std::move(from);
  }

  inline ChooseParticipantReq& operator=(const ChooseParticipantReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChooseParticipantReq& operator=(ChooseParticipantReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChooseParticipantReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChooseParticipantReq* internal_default_instance() {
    return reinterpret_cast<const ChooseParticipantReq*>(
               &_ChooseParticipantReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChooseParticipantReq& a, ChooseParticipantReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ChooseParticipantReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChooseParticipantReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChooseParticipantReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChooseParticipantReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChooseParticipantReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChooseParticipantReq& from) {
    ChooseParticipantReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChooseParticipantReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChatApp.ChooseParticipantReq";
  }
  protected:
  explicit ChooseParticipantReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kPartnerNameFieldNumber = 2,
  };
  // string clientName = 1;
  void clear_clientname();
  const std::string& clientname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientname();
  PROTOBUF_NODISCARD std::string* release_clientname();
  void set_allocated_clientname(std::string* clientname);
  private:
  const std::string& _internal_clientname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientname(const std::string& value);
  std::string* _internal_mutable_clientname();
  public:

  // string partnerName = 2;
  void clear_partnername();
  const std::string& partnername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partnername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partnername();
  PROTOBUF_NODISCARD std::string* release_partnername();
  void set_allocated_partnername(std::string* partnername);
  private:
  const std::string& _internal_partnername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partnername(const std::string& value);
  std::string* _internal_mutable_partnername();
  public:

  // @@protoc_insertion_point(class_scope:ChatApp.ChooseParticipantReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partnername_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class ChooseParticipantResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChatApp.ChooseParticipantResp) */ {
 public:
  inline ChooseParticipantResp() : ChooseParticipantResp(nullptr) {}
  ~ChooseParticipantResp() override;
  explicit PROTOBUF_CONSTEXPR ChooseParticipantResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChooseParticipantResp(const ChooseParticipantResp& from);
  ChooseParticipantResp(ChooseParticipantResp&& from) noexcept
    : ChooseParticipantResp() {
    *this = ::std::move(from);
  }

  inline ChooseParticipantResp& operator=(const ChooseParticipantResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChooseParticipantResp& operator=(ChooseParticipantResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChooseParticipantResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChooseParticipantResp* internal_default_instance() {
    return reinterpret_cast<const ChooseParticipantResp*>(
               &_ChooseParticipantResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ChooseParticipantResp& a, ChooseParticipantResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ChooseParticipantResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChooseParticipantResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChooseParticipantResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChooseParticipantResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChooseParticipantResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChooseParticipantResp& from) {
    ChooseParticipantResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChooseParticipantResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChatApp.ChooseParticipantResp";
  }
  protected:
  explicit ChooseParticipantResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfirmationFieldNumber = 1,
  };
  // string confirmation = 1;
  void clear_confirmation();
  const std::string& confirmation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_confirmation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_confirmation();
  PROTOBUF_NODISCARD std::string* release_confirmation();
  void set_allocated_confirmation(std::string* confirmation);
  private:
  const std::string& _internal_confirmation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_confirmation(const std::string& value);
  std::string* _internal_mutable_confirmation();
  public:

  // @@protoc_insertion_point(class_scope:ChatApp.ChooseParticipantResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr confirmation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class SendMessageReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChatApp.SendMessageReq) */ {
 public:
  inline SendMessageReq() : SendMessageReq(nullptr) {}
  ~SendMessageReq() override;
  explicit PROTOBUF_CONSTEXPR SendMessageReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageReq(const SendMessageReq& from);
  SendMessageReq(SendMessageReq&& from) noexcept
    : SendMessageReq() {
    *this = ::std::move(from);
  }

  inline SendMessageReq& operator=(const SendMessageReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageReq& operator=(SendMessageReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageReq* internal_default_instance() {
    return reinterpret_cast<const SendMessageReq*>(
               &_SendMessageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SendMessageReq& a, SendMessageReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageReq& from) {
    SendMessageReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChatApp.SendMessageReq";
  }
  protected:
  explicit SendMessageReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendMessageReqFieldNumber = 1,
    kClientFieldNumber = 2,
    kPartnerNameFieldNumber = 3,
  };
  // string sendMessageReq = 1;
  void clear_sendmessagereq();
  const std::string& sendmessagereq() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sendmessagereq(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sendmessagereq();
  PROTOBUF_NODISCARD std::string* release_sendmessagereq();
  void set_allocated_sendmessagereq(std::string* sendmessagereq);
  private:
  const std::string& _internal_sendmessagereq() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendmessagereq(const std::string& value);
  std::string* _internal_mutable_sendmessagereq();
  public:

  // string client = 2;
  void clear_client();
  const std::string& client() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client();
  PROTOBUF_NODISCARD std::string* release_client();
  void set_allocated_client(std::string* client);
  private:
  const std::string& _internal_client() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client(const std::string& value);
  std::string* _internal_mutable_client();
  public:

  // string partnerName = 3;
  void clear_partnername();
  const std::string& partnername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partnername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partnername();
  PROTOBUF_NODISCARD std::string* release_partnername();
  void set_allocated_partnername(std::string* partnername);
  private:
  const std::string& _internal_partnername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partnername(const std::string& value);
  std::string* _internal_mutable_partnername();
  public:

  // @@protoc_insertion_point(class_scope:ChatApp.SendMessageReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sendmessagereq_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partnername_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class SendMessageResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChatApp.SendMessageResp) */ {
 public:
  inline SendMessageResp() : SendMessageResp(nullptr) {}
  ~SendMessageResp() override;
  explicit PROTOBUF_CONSTEXPR SendMessageResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageResp(const SendMessageResp& from);
  SendMessageResp(SendMessageResp&& from) noexcept
    : SendMessageResp() {
    *this = ::std::move(from);
  }

  inline SendMessageResp& operator=(const SendMessageResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageResp& operator=(SendMessageResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageResp* internal_default_instance() {
    return reinterpret_cast<const SendMessageResp*>(
               &_SendMessageResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SendMessageResp& a, SendMessageResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageResp& from) {
    SendMessageResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChatApp.SendMessageResp";
  }
  protected:
  explicit SendMessageResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendMessageRespFieldNumber = 1,
  };
  // string sendMessageResp = 1;
  void clear_sendmessageresp();
  const std::string& sendmessageresp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sendmessageresp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sendmessageresp();
  PROTOBUF_NODISCARD std::string* release_sendmessageresp();
  void set_allocated_sendmessageresp(std::string* sendmessageresp);
  private:
  const std::string& _internal_sendmessageresp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendmessageresp(const std::string& value);
  std::string* _internal_mutable_sendmessageresp();
  public:

  // @@protoc_insertion_point(class_scope:ChatApp.SendMessageResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sendmessageresp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegisterReq

// string name = 1;
inline void RegisterReq::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RegisterReq::name() const {
  // @@protoc_insertion_point(field_get:ChatApp.RegisterReq.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterReq::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatApp.RegisterReq.name)
}
inline std::string* RegisterReq::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ChatApp.RegisterReq.name)
  return _s;
}
inline const std::string& RegisterReq::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RegisterReq::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterReq::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterReq::release_name() {
  // @@protoc_insertion_point(field_release:ChatApp.RegisterReq.name)
  return _impl_.name_.Release();
}
inline void RegisterReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatApp.RegisterReq.name)
}

// -------------------------------------------------------------------

// RegisterResp

// string messageConfirmation = 1;
inline void RegisterResp::clear_messageconfirmation() {
  _impl_.messageconfirmation_.ClearToEmpty();
}
inline const std::string& RegisterResp::messageconfirmation() const {
  // @@protoc_insertion_point(field_get:ChatApp.RegisterResp.messageConfirmation)
  return _internal_messageconfirmation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterResp::set_messageconfirmation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.messageconfirmation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatApp.RegisterResp.messageConfirmation)
}
inline std::string* RegisterResp::mutable_messageconfirmation() {
  std::string* _s = _internal_mutable_messageconfirmation();
  // @@protoc_insertion_point(field_mutable:ChatApp.RegisterResp.messageConfirmation)
  return _s;
}
inline const std::string& RegisterResp::_internal_messageconfirmation() const {
  return _impl_.messageconfirmation_.Get();
}
inline void RegisterResp::_internal_set_messageconfirmation(const std::string& value) {
  
  _impl_.messageconfirmation_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterResp::_internal_mutable_messageconfirmation() {
  
  return _impl_.messageconfirmation_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterResp::release_messageconfirmation() {
  // @@protoc_insertion_point(field_release:ChatApp.RegisterResp.messageConfirmation)
  return _impl_.messageconfirmation_.Release();
}
inline void RegisterResp::set_allocated_messageconfirmation(std::string* messageconfirmation) {
  if (messageconfirmation != nullptr) {
    
  } else {
    
  }
  _impl_.messageconfirmation_.SetAllocated(messageconfirmation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.messageconfirmation_.IsDefault()) {
    _impl_.messageconfirmation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatApp.RegisterResp.messageConfirmation)
}

// -------------------------------------------------------------------

// ChooseParticipantReq

// string clientName = 1;
inline void ChooseParticipantReq::clear_clientname() {
  _impl_.clientname_.ClearToEmpty();
}
inline const std::string& ChooseParticipantReq::clientname() const {
  // @@protoc_insertion_point(field_get:ChatApp.ChooseParticipantReq.clientName)
  return _internal_clientname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChooseParticipantReq::set_clientname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatApp.ChooseParticipantReq.clientName)
}
inline std::string* ChooseParticipantReq::mutable_clientname() {
  std::string* _s = _internal_mutable_clientname();
  // @@protoc_insertion_point(field_mutable:ChatApp.ChooseParticipantReq.clientName)
  return _s;
}
inline const std::string& ChooseParticipantReq::_internal_clientname() const {
  return _impl_.clientname_.Get();
}
inline void ChooseParticipantReq::_internal_set_clientname(const std::string& value) {
  
  _impl_.clientname_.Set(value, GetArenaForAllocation());
}
inline std::string* ChooseParticipantReq::_internal_mutable_clientname() {
  
  return _impl_.clientname_.Mutable(GetArenaForAllocation());
}
inline std::string* ChooseParticipantReq::release_clientname() {
  // @@protoc_insertion_point(field_release:ChatApp.ChooseParticipantReq.clientName)
  return _impl_.clientname_.Release();
}
inline void ChooseParticipantReq::set_allocated_clientname(std::string* clientname) {
  if (clientname != nullptr) {
    
  } else {
    
  }
  _impl_.clientname_.SetAllocated(clientname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientname_.IsDefault()) {
    _impl_.clientname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatApp.ChooseParticipantReq.clientName)
}

// string partnerName = 2;
inline void ChooseParticipantReq::clear_partnername() {
  _impl_.partnername_.ClearToEmpty();
}
inline const std::string& ChooseParticipantReq::partnername() const {
  // @@protoc_insertion_point(field_get:ChatApp.ChooseParticipantReq.partnerName)
  return _internal_partnername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChooseParticipantReq::set_partnername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.partnername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatApp.ChooseParticipantReq.partnerName)
}
inline std::string* ChooseParticipantReq::mutable_partnername() {
  std::string* _s = _internal_mutable_partnername();
  // @@protoc_insertion_point(field_mutable:ChatApp.ChooseParticipantReq.partnerName)
  return _s;
}
inline const std::string& ChooseParticipantReq::_internal_partnername() const {
  return _impl_.partnername_.Get();
}
inline void ChooseParticipantReq::_internal_set_partnername(const std::string& value) {
  
  _impl_.partnername_.Set(value, GetArenaForAllocation());
}
inline std::string* ChooseParticipantReq::_internal_mutable_partnername() {
  
  return _impl_.partnername_.Mutable(GetArenaForAllocation());
}
inline std::string* ChooseParticipantReq::release_partnername() {
  // @@protoc_insertion_point(field_release:ChatApp.ChooseParticipantReq.partnerName)
  return _impl_.partnername_.Release();
}
inline void ChooseParticipantReq::set_allocated_partnername(std::string* partnername) {
  if (partnername != nullptr) {
    
  } else {
    
  }
  _impl_.partnername_.SetAllocated(partnername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.partnername_.IsDefault()) {
    _impl_.partnername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatApp.ChooseParticipantReq.partnerName)
}

// -------------------------------------------------------------------

// ChooseParticipantResp

// string confirmation = 1;
inline void ChooseParticipantResp::clear_confirmation() {
  _impl_.confirmation_.ClearToEmpty();
}
inline const std::string& ChooseParticipantResp::confirmation() const {
  // @@protoc_insertion_point(field_get:ChatApp.ChooseParticipantResp.confirmation)
  return _internal_confirmation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChooseParticipantResp::set_confirmation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.confirmation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatApp.ChooseParticipantResp.confirmation)
}
inline std::string* ChooseParticipantResp::mutable_confirmation() {
  std::string* _s = _internal_mutable_confirmation();
  // @@protoc_insertion_point(field_mutable:ChatApp.ChooseParticipantResp.confirmation)
  return _s;
}
inline const std::string& ChooseParticipantResp::_internal_confirmation() const {
  return _impl_.confirmation_.Get();
}
inline void ChooseParticipantResp::_internal_set_confirmation(const std::string& value) {
  
  _impl_.confirmation_.Set(value, GetArenaForAllocation());
}
inline std::string* ChooseParticipantResp::_internal_mutable_confirmation() {
  
  return _impl_.confirmation_.Mutable(GetArenaForAllocation());
}
inline std::string* ChooseParticipantResp::release_confirmation() {
  // @@protoc_insertion_point(field_release:ChatApp.ChooseParticipantResp.confirmation)
  return _impl_.confirmation_.Release();
}
inline void ChooseParticipantResp::set_allocated_confirmation(std::string* confirmation) {
  if (confirmation != nullptr) {
    
  } else {
    
  }
  _impl_.confirmation_.SetAllocated(confirmation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.confirmation_.IsDefault()) {
    _impl_.confirmation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatApp.ChooseParticipantResp.confirmation)
}

// -------------------------------------------------------------------

// SendMessageReq

// string sendMessageReq = 1;
inline void SendMessageReq::clear_sendmessagereq() {
  _impl_.sendmessagereq_.ClearToEmpty();
}
inline const std::string& SendMessageReq::sendmessagereq() const {
  // @@protoc_insertion_point(field_get:ChatApp.SendMessageReq.sendMessageReq)
  return _internal_sendmessagereq();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageReq::set_sendmessagereq(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sendmessagereq_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatApp.SendMessageReq.sendMessageReq)
}
inline std::string* SendMessageReq::mutable_sendmessagereq() {
  std::string* _s = _internal_mutable_sendmessagereq();
  // @@protoc_insertion_point(field_mutable:ChatApp.SendMessageReq.sendMessageReq)
  return _s;
}
inline const std::string& SendMessageReq::_internal_sendmessagereq() const {
  return _impl_.sendmessagereq_.Get();
}
inline void SendMessageReq::_internal_set_sendmessagereq(const std::string& value) {
  
  _impl_.sendmessagereq_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageReq::_internal_mutable_sendmessagereq() {
  
  return _impl_.sendmessagereq_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageReq::release_sendmessagereq() {
  // @@protoc_insertion_point(field_release:ChatApp.SendMessageReq.sendMessageReq)
  return _impl_.sendmessagereq_.Release();
}
inline void SendMessageReq::set_allocated_sendmessagereq(std::string* sendmessagereq) {
  if (sendmessagereq != nullptr) {
    
  } else {
    
  }
  _impl_.sendmessagereq_.SetAllocated(sendmessagereq, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sendmessagereq_.IsDefault()) {
    _impl_.sendmessagereq_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatApp.SendMessageReq.sendMessageReq)
}

// string client = 2;
inline void SendMessageReq::clear_client() {
  _impl_.client_.ClearToEmpty();
}
inline const std::string& SendMessageReq::client() const {
  // @@protoc_insertion_point(field_get:ChatApp.SendMessageReq.client)
  return _internal_client();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageReq::set_client(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatApp.SendMessageReq.client)
}
inline std::string* SendMessageReq::mutable_client() {
  std::string* _s = _internal_mutable_client();
  // @@protoc_insertion_point(field_mutable:ChatApp.SendMessageReq.client)
  return _s;
}
inline const std::string& SendMessageReq::_internal_client() const {
  return _impl_.client_.Get();
}
inline void SendMessageReq::_internal_set_client(const std::string& value) {
  
  _impl_.client_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageReq::_internal_mutable_client() {
  
  return _impl_.client_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageReq::release_client() {
  // @@protoc_insertion_point(field_release:ChatApp.SendMessageReq.client)
  return _impl_.client_.Release();
}
inline void SendMessageReq::set_allocated_client(std::string* client) {
  if (client != nullptr) {
    
  } else {
    
  }
  _impl_.client_.SetAllocated(client, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_.IsDefault()) {
    _impl_.client_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatApp.SendMessageReq.client)
}

// string partnerName = 3;
inline void SendMessageReq::clear_partnername() {
  _impl_.partnername_.ClearToEmpty();
}
inline const std::string& SendMessageReq::partnername() const {
  // @@protoc_insertion_point(field_get:ChatApp.SendMessageReq.partnerName)
  return _internal_partnername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageReq::set_partnername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.partnername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatApp.SendMessageReq.partnerName)
}
inline std::string* SendMessageReq::mutable_partnername() {
  std::string* _s = _internal_mutable_partnername();
  // @@protoc_insertion_point(field_mutable:ChatApp.SendMessageReq.partnerName)
  return _s;
}
inline const std::string& SendMessageReq::_internal_partnername() const {
  return _impl_.partnername_.Get();
}
inline void SendMessageReq::_internal_set_partnername(const std::string& value) {
  
  _impl_.partnername_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageReq::_internal_mutable_partnername() {
  
  return _impl_.partnername_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageReq::release_partnername() {
  // @@protoc_insertion_point(field_release:ChatApp.SendMessageReq.partnerName)
  return _impl_.partnername_.Release();
}
inline void SendMessageReq::set_allocated_partnername(std::string* partnername) {
  if (partnername != nullptr) {
    
  } else {
    
  }
  _impl_.partnername_.SetAllocated(partnername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.partnername_.IsDefault()) {
    _impl_.partnername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatApp.SendMessageReq.partnerName)
}

// -------------------------------------------------------------------

// SendMessageResp

// string sendMessageResp = 1;
inline void SendMessageResp::clear_sendmessageresp() {
  _impl_.sendmessageresp_.ClearToEmpty();
}
inline const std::string& SendMessageResp::sendmessageresp() const {
  // @@protoc_insertion_point(field_get:ChatApp.SendMessageResp.sendMessageResp)
  return _internal_sendmessageresp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageResp::set_sendmessageresp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sendmessageresp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChatApp.SendMessageResp.sendMessageResp)
}
inline std::string* SendMessageResp::mutable_sendmessageresp() {
  std::string* _s = _internal_mutable_sendmessageresp();
  // @@protoc_insertion_point(field_mutable:ChatApp.SendMessageResp.sendMessageResp)
  return _s;
}
inline const std::string& SendMessageResp::_internal_sendmessageresp() const {
  return _impl_.sendmessageresp_.Get();
}
inline void SendMessageResp::_internal_set_sendmessageresp(const std::string& value) {
  
  _impl_.sendmessageresp_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageResp::_internal_mutable_sendmessageresp() {
  
  return _impl_.sendmessageresp_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageResp::release_sendmessageresp() {
  // @@protoc_insertion_point(field_release:ChatApp.SendMessageResp.sendMessageResp)
  return _impl_.sendmessageresp_.Release();
}
inline void SendMessageResp::set_allocated_sendmessageresp(std::string* sendmessageresp) {
  if (sendmessageresp != nullptr) {
    
  } else {
    
  }
  _impl_.sendmessageresp_.SetAllocated(sendmessageresp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sendmessageresp_.IsDefault()) {
    _impl_.sendmessageresp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChatApp.SendMessageResp.sendMessageResp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ChatApp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chat_2eproto
